void fcfs(const string &filename) {
    Queue ready_queue;
//    int time = 0;
    //calculated measurements
    int avg_cpu_burst;
    int avg_waiting_time;
    int avg_turnaround_time;
    int avg_response_time;
    int total_context_switches;
    ProcessArray *all_processes = new ProcessArray();

    process_file(filename, all_processes);

    int processes_queued = 0;
    int completed_processes = 0;
    double current_time = 0;
    PCB* currently_running_process = nullptr;

    while (completed_processes < all_processes->count) {
        //get arriving processes at this time from all_processes & add to ready queue
        while (processes_queued < all_processes->count && all_processes->arr[processes_queued].arrival <= current_time) {
            ready_queue.enqueue(all_processes->arr[processes_queued]);
            processes_queued++;
        }
        //check if currently running process - if not, add context switching time and get next process from ready queue
        if (currently_running_process == nullptr && ready_queue.head != nullptr) { //start new process
            if (current_time != 0) {  // no context switching for first process
                current_time += CONTEXT_SWITCHING_COST;
            }
            currently_running_process = &ready_queue.head->process;
            ready_queue.dequeue();
            Burst* new_burst = new Burst(current_time); //begin new burst
            currently_running_process->bursts[currently_running_process->num_bursts] = *new_burst;
        }
//        else { //continue with current process
//            cout << "continuing with process " << endl;
//        }

        //run process - decrement time still needed
        currently_running_process->time_left_to_run--;

        //increment current time
        current_time += 1;

        //if time still needed is 0, update burst, increment completed processes & set currently running to null
        if (currently_running_process->time_left_to_run == 0) {
            currently_running_process->bursts[currently_running_process->num_bursts].end_time = current_time;

            cout << "Process " << currently_running_process->pid << " ran from "
                << currently_running_process->bursts[currently_running_process->num_bursts].start_time << " to "
                << currently_running_process->bursts[currently_running_process->num_bursts].end_time << endl;

            completed_processes ++;
            cout << "Completed process " << completed_processes << endl;

            currently_running_process->completion_time = currently_running_process->bursts[currently_running_process->num_bursts].end_time;
            //waiting time for fcfs is start time minus arrival time
            currently_running_process->waiting_time = currently_running_process->bursts[0].start_time - currently_running_process->arrival;

            //update all_processes with completed process info
            for (int a = 0; a < all_processes->count; a++) {
                if (all_processes->arr[a].pid == currently_running_process->pid) {
                    all_processes->arr[a] = *currently_running_process;
                }
            }

            currently_running_process = nullptr;
        }
    }
cout << "Done running all processes." << endl;
}
